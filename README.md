# MT-HOPE: Möbius-Twistor Nested Learning Architecture

基于莫比乌斯-扭量理论的嵌套学习（Nested Learning）架构，实现Google Research的HOPE架构。

## 概述

本项目实现了基于**Nested Learning范式**（见NL.pdf论文）的深度学习架构，结合扭量理论（Twistor Theory）和莫比乌斯拓扑结构，实现了Google Research提出的HOPE（Self-modifying Architecture with Continuum Memory）架构。

**重要说明**：这不是传统的Transformer架构，而是基于Nested Learning范式的新架构，采用纯Recurrent结构（无注意力机制），通过嵌套优化和多层级学习实现持续学习能力。

### 核心组件

1. **旋量嵌入层 (Spinor Embedding)** - 将Token映射为复数扭量表示（ω和π两个分量）
2. **关联注意力机制 (Incidence Attention)** - 基于扭量关联度的注意力计算，包含莫比乌斯项
3. **莫比乌斯层 (Möbius Layer)** - 实现拓扑循环结构，支持手性翻转和复共轭
4. **嵌套优化器 (Nested Optimizer)** - 支持嵌套学习范式的优化器包装
5. **HOPE架构集成 (Hope Integration)** - 完整的HOPE-MT架构实现

## 理论背景

### Nested Learning 范式

根据NL.pdf论文，Nested Learning（嵌套学习）是一种新的学习范式，将模型表示为一系列嵌套的、多层级的、和/或并行的优化问题，每个问题都有自己的"上下文流"。

- **传统深度学习**：通过堆叠层来增加模型容量，但深度可能不改变计算深度
- **Nested Learning**：通过嵌套优化和多层级学习，实现更高阶的上下文学习能力
- **核心洞察**：现有的深度学习方法通过压缩自己的上下文流来学习，这解释了为什么大模型会出现上下文学习能力

### 扭量理论 (Twistor Theory)

本项目将Token从传统的高维空间中的**点（向量）**表示提升为**光线（扭量）**表示。

- **传统表示**：Token作为向量，关注点与点的距离
- **扭量表示**：Token作为扭量（两个复数分量ω和π），关注线与线的相交关系（关联关系）
- **拓扑结构**：在层与层之间引入莫比乌斯拓扑结构，实现拓扑循环

### HOPE架构

HOPE（Self-modifying Architecture with Continuum Memory）是Google Research在NL.pdf论文中提出的架构，基于Nested Learning范式，包含：

- **Self-Modifying Titans** - 自我修正序列模型，学习如何修改自己的更新算法
- **Continuum Memory System (CMS)** - 连续记忆系统，泛化了传统的"长期/短期记忆"观点
- **Nested Learning Paradigm** - 嵌套学习范式，通过多层级嵌套优化实现持续学习

根据NL.pdf，HOPE架构在语言建模、持续学习和长上下文推理任务上表现出色。

## 模型特点

### 核心创新点

1. **扭量几何表示**
   - 将传统向量表示提升为扭量（Twistor）表示，每个Token由两个复数分量（ω, π）编码
   - 在复射影空间中建模，捕获更丰富的几何结构
   - 支持手性翻转和复共轭操作，增强模型的表达能力

2. **莫比乌斯拓扑结构**
   - 引入莫比乌斯变换实现拓扑循环，支持自适应耦合
   - 多层莫比乌斯循环（默认3层，可配置）实现信息的多尺度传播
   - 自适应演化率机制，根据输入动态调整变换参数

3. **纯Recurrent架构（非Transformer）**
   - **完全移除注意力机制**，采用纯循环结构（基于HOPE的Titans设计）
   - 这是基于Nested Learning的架构，不是Transformer的变体
   - 支持双向循环，捕获前后文信息
   - 循环层间通过莫比乌斯层实现拓扑连接
   - 计算复杂度从O(n²)降低到O(n)，更适合长序列建模

4. **嵌套学习范式**
   - 多层级嵌套优化（默认5-6层），ω和π分量独立优化
   - 动态嵌套权重，根据训练进度自适应调整
   - 层级学习率策略，深层使用较小学习率，浅层使用较大学习率
   - 约束损失机制，保持扭量几何约束

5. **持续记忆系统**
   - 扭量记忆系统（TwistorMemorySystem）实现循环记忆更新
   - 相位压缩机制，高效存储和检索记忆
   - 多循环记忆更新，增强长期依赖建模能力

6. **自我修正机制**
   - 扭量自我修正模块（TwistorSelfModifyingRecurrent）实现参数自适应调整
   - 多尺度演化模式，在不同时间尺度上优化模型
   - 自适应演化率，根据梯度信息动态调整修正强度

## 架构原理

### 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    扭量化HOPE架构 (Twistor HOPE)                  │
└─────────────────────────────────────────────────────────────────┘

输入: Token IDs (batch_size, seq_len)
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 1. SpinorEmbedding (旋量嵌入层)                                   │
│    - 将Token映射为扭量表示                                        │
│    - 输出: (batch, seq, dim*2) = [ω, π]                          │
│    - ω分量: (batch, seq, dim) - 频率/方向信息                     │
│    - π分量: (batch, seq, dim) - 位置/相位信息                     │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. TwistorSelfModifyingRecurrent (扭量自我修正，Recurrent版本)   │
│    │                                                             │
│    ├─→ TwistorTitansRecurrent (扭量化循环层)                    │
│    │   - 双向/单向循环处理                                        │
│    │   - 隐藏状态维度: hidden_dim*2                             │
│    │   - 支持多层堆叠 (num_recurrent_layers)                    │
│    │                                                             │
│    └─→ AdaptiveMobiusLayer (自适应莫比乌斯层)                    │
│        - 莫比乌斯变换: z → (az+b)/(cz+d)                        │
│        - 多层循环 (num_mobius_cycles)                            │
│        - 自适应耦合系数                                           │
│        - 支持手性翻转和复共轭                                     │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. TwistorMemorySystem (扭量记忆系统)                             │
│    - 记忆数量: num_memories                                       │
│    - 循环更新: num_memory_cycles 次                              │
│    - 相位压缩: PhaseCompression (可选)                           │
│    - 输出: 更新后的记忆 + 当前状态                                 │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. TwistorNestedLearning (扭量嵌套学习)                          │
│    │                                                             │
│    ├─→ OmegaNestedOptimizer (ω分量优化器)                       │
│    │   - 独立优化ω分量                                            │
│    │   - 层级学习率: lr_omega * level_factor                     │
│    │                                                             │
│    ├─→ PiNestedOptimizer (π分量优化器)                          │
│    │   - 独立优化π分量                                            │
│    │   - 层级学习率: lr_pi * level_factor                        │
│    │                                                             │
│    └─→ Constraint Loss (约束损失)                                │
│        - 保持扭量几何约束: |ω·π| = constant                     │
│        - 防止表示退化                                             │
└─────────────────────────────────────────────────────────────────┘
  │
  ▼
输出: (batch_size, seq_len, dim)
```

### 数据流可视化

```
Token序列: [t₁, t₂, ..., tₙ]
    │
    ▼
┌─────────┐
│ Embed   │ → [ω₁,π₁], [ω₂,π₂], ..., [ωₙ,πₙ]
└─────────┘
    │
    ▼
┌─────────────────────────────────────┐
│ Recurrent Processing                │
│                                      │
│  h₀ → [Möbius] → h₁ → [Möbius] → h₂ │
│   ↑                                  │
│   └─────────── 循环连接 ─────────────┘
└─────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────┐
│ Memory System                        │
│                                      │
│  M = [m₁, m₂, ..., mₖ]              │
│  更新: M ← f(M, h)                  │
└─────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────┐
│ Nested Learning                      │
│                                      │
│  Level 1: [ω, π]                    │
│    ↓                                 │
│  Level 2: [ω', π']                  │
│    ↓                                 │
│  ...                                 │
│    ↓                                 │
│  Level N: [ωⁿ, πⁿ]                  │
└─────────────────────────────────────┘
    │
    ▼
输出表示
```

### 关键组件详解

#### 1. 旋量嵌入 (Spinor Embedding)

将离散Token映射到连续扭量空间：

```
Token ID → [ω, π] ∈ ℂ²
```

- **ω分量**: 编码频率和方向信息，对应扭量的"方向部分"
- **π分量**: 编码位置和相位信息，对应扭量的"位置部分"
- **几何意义**: 在复射影空间CP³中表示，每个扭量对应一条光线

#### 2. 莫比乌斯变换 (Möbius Transformation)

实现拓扑循环结构：

```
z → (az + b) / (cz + d)
```

其中 `a, b, c, d` 是复数参数，满足 `ad - bc ≠ 0`。

- **拓扑性质**: 保持角度和圆的性质
- **自适应耦合**: 根据输入动态调整参数
- **多层循环**: 通过多次应用实现复杂变换

#### 3. 嵌套学习 (Nested Learning)

多层级优化策略：

```
Level 1: 优化 [ω₁, π₁]  with lr₁
  ↓
Level 2: 优化 [ω₂, π₂]  with lr₂ = lr₁ * α
  ↓
...
  ↓
Level N: 优化 [ωₙ, πₙ]  with lrₙ = lr₁ * α^(N-1)
```

- **层级学习率**: 深层使用较小学习率，防止过度更新
- **动态权重**: 根据训练进度调整各层级权重
- **约束保持**: 通过约束损失保持扭量几何性质

#### 4. 记忆系统 (Memory System)

循环记忆更新机制：

```
M(t+1) = f(M(t), h(t), α)
```

其中：
- `M(t)`: 时刻t的记忆状态
- `h(t)`: 当前隐藏状态
- `α`: 更新率（通常0.1）

- **相位压缩**: 通过相位信息压缩记忆，节省存储
- **多循环更新**: 多次循环更新增强记忆稳定性

## 安装

安装依赖包：`pip install -r requirements.txt`

## 快速开始

### 基本使用

导入所需组件，创建模型实例，进行前向传播。详细示例请参考 `examples/demo.py`。

### 扭量化HOPE架构

使用 `TwistorHopeArchitecture` 创建完整的扭量化HOPE模型，支持多种预设配置。详细使用请参考 `examples/train_optimized.py`。

### 优化训练

使用 `train_optimized.py` 脚本进行优化训练，支持配置选择、混合精度训练、梯度累积等优化功能。

## 运行测试

运行 `examples/demo.py` 进行基础测试，运行 `examples/performance_test.py` 进行性能测试。

## 模型配置

项目提供了多种预设配置，适用于不同的计算资源和性能需求：

### 预设配置

支持 `small`, `medium`, `recommended`, `large` 四种预设配置。使用 `model_configs.get_config()` 获取配置，使用 `create_full_config()` 创建完整配置。

### 配置对比

| 配置 | 维度 | 循环层数 | 嵌套层级 | 记忆数量 | 双向 | 参数量(估算) |
|------|------|----------|----------|----------|------|--------------|
| small | 128 | 2 | 5 | 3 | 否 | ~4.7M |
| medium | 192 | 2 | 5 | 4 | 否 | ~8.5M |
| **recommended** | **256** | **3** | **6** | **5** | **是** | **~25M** |
| large | 512 | 4 | 8 | 8 | 是 | ~100M |

### 推荐配置

推荐配置 (`recommended`) 提供了性能与资源消耗的最佳平衡：

- **维度**: 256
- **循环层数**: 3
- **嵌套层级**: 6
- **记忆数量**: 5
- **双向循环**: 是
- **参数量**: ~25M

适合在GTX 1650 (4GB显存) 等中等GPU上训练，通过混合精度训练可进一步降低显存占用。

## 架构流程

### 扭量化HOPE架构（基于Nested Learning的Recurrent架构）

Token IDs → SpinorEmbedding (扭量表示: ω和π) → TwistorSelfModifyingRecurrent (扭量自我修正，Recurrent版本) → TwistorTitansRecurrent (扭量化循环层) → AdaptiveMobiusLayer (自适应莫比乌斯层) → TwistorMemorySystem (扭量记忆系统，循环更新) → TwistorNestedLearning (扭量嵌套学习) → 输出

**重要说明**:
- 这是基于**Nested Learning范式**的架构，不是Transformer架构
- 采用纯Recurrent结构，**完全移除了注意力机制**
- 符合Google HOPE架构的Titans设计（见NL.pdf论文）
- 通过嵌套优化实现多层级学习，支持持续学习和上下文学习

## 关键特性

1. **复数扭量表示** - 每个Token用两个复数分量（ω, π）表示
2. **扭量演化** - 自适应演化率和多尺度演化模式
3. **拓扑循环** - 多层莫比乌斯循环，支持自适应耦合系数
4. **嵌套学习** - 多层级嵌套学习（默认5层，推荐配置6层），支持动态权重和层级学习率
5. **持续学习** - 与HOPE架构的CMS集成，支持持续学习
6. **Recurrent架构** - 真正的循环结构，完全移除注意力机制

## 训练优化

### 混合精度训练 (AMP)

使用混合精度训练可以节省约50%的显存，同时提升约30%的训练速度。在 `train_gpu.py` 中自动检测GPU并启用。

### 梯度累积

通过梯度累积可以模拟更大的batch size，而不增加显存占用。支持自定义累积步数。

### 学习率调度

支持Warmup + Cosine退火学习率调度。前10%步数用于warmup，之后使用cosine退火。

### 优化训练脚本

使用 `train_optimized.py` 可以快速开始优化训练，支持配置选择、自定义batch size、学习率等参数。

### 训练优化功能

- ✅ **混合精度训练** - 自动检测GPU并启用，节省50%显存
- ✅ **梯度累积** - 支持自定义累积步数
- ✅ **学习率调度** - Warmup + Cosine退火
- ✅ **NaN检测和跳过** - 自动跳过包含NaN/Inf的batch
- ✅ **梯度裁剪** - 防止梯度爆炸
- ✅ **动态嵌套权重** - 根据训练进度调整嵌套权重
- ✅ **层级学习率** - 深层使用较小学习率，浅层使用较大学习率

## 性能对比

### 不同配置的性能指标

| 配置 | 参数量 | 内存占用 | 前向传播 | 训练速度 | 适用场景 |
|------|--------|----------|----------|----------|----------|
| small | 4.7M | ~36 MB | ~15 ms | 快 | 快速实验、小数据集 |
| medium | 8.5M | ~65 MB | ~22 ms | 中等 | 中等规模任务 |
| **recommended** | **25M** | **~150 MB** | **~35 ms** | **中等** | **推荐配置，最佳平衡** |
| large | 100M | ~600 MB | ~120 ms | 慢 | 大规模任务、高性能GPU |

*注：内存占用为训练时估算值，使用混合精度训练可降低约50%*

### 优化效果

使用优化训练脚本 (`train_optimized.py`) 的效果：

- **显存节省**: 混合精度训练可节省约50%显存
- **训练速度**: 提升约30%（混合精度 + 优化）
- **稳定性**: NaN检测和梯度裁剪提升训练稳定性
- **收敛速度**: 学习率调度和动态权重优化收敛速度

### 性能测试

运行 `examples/performance_test.py` 进行性能测试，包括参数量统计、内存占用估算、前向传播速度、训练速度和不同配置对比。

## 文件结构

```
mobi model/
├── model.md                    # 理论文档
├── NL.pdf                      # HOPE架构论文
├── requirements.txt            # 依赖包列表
├── mt_transformer/
│   ├── __init__.py            # 包初始化
│   ├── model_configs.py       # 模型配置模块
│   ├── spinor_embedding.py    # 旋量嵌入层
│   ├── incidence_attention.py # 关联注意力机制
│   ├── mobius_layer.py        # 莫比乌斯层
│   ├── nested_optimizer.py   # 嵌套优化器包装
│   ├── twistor_titans_cell.py # 扭量Titans单元
│   ├── twistor_titans_recurrent.py # 扭量循环层
│   ├── twistor_self_modifying_recurrent.py # 扭量自我修正（Recurrent）
│   ├── twistor_memory_system.py # 扭量记忆系统
│   ├── twistor_nested_learning.py # 扭量嵌套学习
│   └── twistor_hope_architecture.py # 完整扭量化HOPE架构
├── examples/
│   ├── demo.py                # 基础使用示例
│   ├── train_gpu.py           # GPU训练脚本（增强版）
│   ├── train_optimized.py     # 优化训练脚本（推荐）
│   └── performance_test.py    # 性能测试脚本
└── README.md                   # 使用说明
```

## 技术细节

### 复数表示

默认使用**分离实部虚部**的方式（而非`torch.complex64`），便于与HOPE架构的混合计算兼容。

### 维度说明

- 输入维度 `dim`：每个分量的维度
- 旋量嵌入输出：`dim * 2`（ω和π各占`dim`）
- 其他组件输入/输出：`dim * 2`（扭量表示）

### 数值稳定性

注意复数运算的数值精度和梯度稳定性。建议使用梯度裁剪和适当的初始化。

## 影响与意义

### 理论贡献

1. **几何表示创新**
   - 首次将扭量理论系统性地引入深度学习，将Token从点表示提升为光线表示
   - 在复射影空间中建模，捕获传统向量空间无法表达的几何结构
   - 为理解序列模型的几何本质提供了新的视角，展示了Nested Learning范式的几何基础

2. **架构范式突破**
   - 证明了纯Recurrent架构（无注意力机制）在序列建模中的有效性
   - 通过莫比乌斯拓扑结构实现层间信息传递，替代传统残差连接
   - 嵌套学习范式实现了多层级优化，提升训练稳定性和收敛速度

3. **记忆机制创新**
   - 扭量记忆系统实现了更高效的长期依赖建模
   - 相位压缩机制在保持信息完整性的同时降低存储开销
   - 循环记忆更新机制增强了模型的持续学习能力

### 实际应用价值

1. **计算效率**
   - Recurrent架构相比Transformer注意力机制，计算复杂度从O(n²)降低到O(n)
   - 适合长序列建模，显存占用更少
   - 混合精度训练可节省约50%显存，提升约30%训练速度

2. **模型性能**
   - 扭量表示增强了模型的表达能力，在复杂任务上表现更优
   - 嵌套学习范式提升了训练稳定性，减少梯度消失/爆炸问题
   - 自适应机制使模型能够根据数据特性动态调整

3. **可扩展性**
   - 支持多种预设配置，从小规模实验到大规模生产环境
   - 模块化设计，各组件可独立使用或组合
   - 易于集成到现有深度学习框架

### 潜在影响领域

1. **自然语言处理**
   - 长文本理解：Recurrent架构更适合处理长文档
   - 多语言建模：扭量表示可能更好地捕获跨语言语义结构
   - 对话系统：持续记忆系统适合多轮对话场景

2. **科学计算**
   - 物理系统建模：扭量理论本身来自物理学，适合物理系统建模
   - 几何数据处理：复射影空间表示适合处理几何数据
   - 符号推理：嵌套学习可能提升符号推理能力

3. **持续学习**
   - 在线学习：记忆系统支持增量学习
   - 领域适应：自我修正机制支持模型适应新领域
   - 少样本学习：扭量表示可能提升少样本学习能力

### 未来研究方向

1. **理论深化**
   - 扭量表示的理论分析：理解扭量表示的表达能力边界
   - 莫比乌斯变换的优化：寻找最优的拓扑变换参数
   - 嵌套学习的收敛性分析：理论保证嵌套学习的有效性

2. **架构优化**
   - 更高效的记忆压缩算法
   - 自适应循环层数选择
   - 多模态扭量表示扩展

3. **应用拓展**
   - 大规模预训练模型
   - 特定领域微调策略
   - 与其他架构的融合

## 可视化工具

### 架构可视化

项目支持通过代码生成架构图，展示模型的数据流和组件关系。主要可视化内容包括：

1. **数据流图**: 展示从Token输入到最终输出的完整流程
2. **组件关系图**: 展示各模块之间的连接和依赖关系
3. **记忆更新图**: 可视化记忆系统的更新过程
4. **嵌套学习层级图**: 展示嵌套学习的层级结构

### 训练可视化

训练过程中可以可视化：

1. **损失曲线**: 训练损失、验证损失、约束损失
2. **学习率曲线**: 各层级的学习率变化
3. **梯度范数**: 监控训练稳定性
4. **记忆状态**: 记忆向量的变化轨迹

### 使用建议

- 使用 `examples/performance_test.py` 进行性能分析和可视化
- 训练脚本 `train_gpu.py` 输出详细的训练统计信息
- 可以通过修改代码添加自定义可视化功能

## 参考文献

1. **Nested Learning: The Illusion of Deep Learning Architectures** - Google Research (NeurIPS 2025) - **NL.pdf**
   - 本文提出的嵌套学习范式，为HOPE架构的理论基础
   - 阐述了深度学习中"深度"的本质，提出了嵌套优化的重要性
   - **核心贡献**：
     - Deep Optimizers：基于NL的优化器，将梯度优化器（如Adam、SGD with Momentum）视为关联记忆模块
     - Self-Modifying Titans：学习如何修改自己的序列模型
     - Continuum Memory System：泛化传统长期/短期记忆的新记忆系统
     - Hope：结合自修改序列模型和连续记忆系统的学习模块

2. **Twistor Theory** - 扭量理论在深度学习中的应用
   - 扭量理论由Roger Penrose提出，用于描述时空几何
   - 本项目将扭量理论引入深度学习，实现了几何表示创新

3. **Möbius Transformations** - 莫比乌斯变换在神经网络中的应用
   - 莫比乌斯变换是复分析中的重要概念，具有丰富的几何性质
   - 本项目利用莫比乌斯变换实现拓扑循环结构，增强模型表达能力

4. **Self-Modifying Architectures** - Google Research
   - HOPE架构的核心思想：自我修正机制
   - 通过参数自适应调整实现模型动态优化

5. **Continuum Memory Systems** - 连续记忆系统
   - HOPE架构的记忆机制设计
   - 支持持续学习和长期依赖建模

## 许可证

MIT License

## 贡献

欢迎提交Issue和Pull Request！
